1.单向链表 
//实现一个单链表，链表初始为空，支持三种操作：
//向链表头插入一个数；
//删除第 k 个插入的数后面的数；
//在第 k 个插入的数后插入一个数。
//现在要对该链表进行 M 次操作，进行完所有操作后，从头到尾输出整个链表。
//注意:题目中第 k 个插入的数，是按照输入顺序的第 k 个 

//输入格式
//第一行包含整数 M，表示操作次数。
//接下来 M 行，每行包含一个操作命令，操作命令可能为以下几种：

//H x，表示向链表头插入一个数 x。
//D k，表示删除第 k 个插入的数后面的数（当 k 为 0 时，表示删除头结点）
//I k x，表示在第 k 个插入的数后面插入一个数 x（此操作中 k 均大于 0）

//输出格式
//共一行，将整个链表从头到尾输出。

//数据范围
//1≤M≤100000
//所有操作保证合法。

//输入样例：
//10
//H 9
//I 1 1
//D 1
//D 0
//H 6
//I 3 6
//I 4 5
//I 4 5
//I 3 4
//D 6

//输出样例：
//6 4 6 5

//第一遍  2022/03/12
//第二遍  2022/03/25
//第三遍  2022/04/11
//第四遍  2022/05/02 
#include <iostream>
using namespace std;
const int N = 1e5+10;

//*** head  表示头节点下标
//e[i]  表示当前节点 i 的值
//ne[i] 表示当前节点 i 的 next 指针是多少
//*** idx   存储当前已经用到了那个点
int head,e[N],ne[N],idx;

//初始化							//头节点为 -1 ，下标计数器为 0  ！！！！ 
void init()
{
    head = -1;						//从 -1 开始是为了让第一个插入的数下标为 0 
    idx = 0;						//计数器当然从 0 开始 
}

//*****将x元素插入头节点***** 
void add_to_head(int x)
{
    e[idx] = x;         			//将当前结点的值变为 x
    ne[idx] = head;     			//将当前结点的 next 指针指向 head 所指的结点
    head = idx;         			//让头节点指向当前节点
    idx++;              			//跳到下一个结点
}

//*****将x元素插入k结点的后面*****
void add(int k,int x)
{
    e[idx] = x;         			//将当前结点的值变为 x
    ne[idx] = ne[k];    			//将当前结点的 next 指针指向 k 所指的结点（ k+1 结点）
    ne[k] = idx;        			//让 k 节点指向当前节点
    idx++;             				 //跳到下一个结点
}

//*****将下标是k的下一个点删除掉*****
void remove(int k)
{
    ne[k] = ne[ne[k]];				//原理是让前一个节点的指针直接指向下一个节点，本质上是跳过当前节点 
}

int main()
{
    int m;
    cin >> m;
    
    init();												//链表要先初始化 ！！ 
    
    char op;
    int x,k;
    while(m--)
    {
        cin >> op;
        if(op=='H')										//条件语句用的是 if  ---  else if  ---- else  结构 ！！！ 
        {
            cin >> x;
            add_to_head(x);
        }
        else if(op=='D')
        {
            cin >> k;
            if(k==0) head = ne[head];      				//特判头部结点（因为没有前一个节点了，直接删掉 head ）
            else remove(k-1);							//由于数组从 0 开始存储 ， 因此第 k 个数的下标为 k-1 ！！！ 
        }
        else
        {
            cin >> k >> x;
            add(k-1,x);									//由于数组从 0 开始存储 ， 因此第 k 个数的下标为 k-1 ！！！ 
        }
    }
    
    int i;
    for(i=head;i!=-1;i=ne[i]) cout << e[i] << ' ';		//特殊遍历方式，利用数组模拟链表的特性 ， head 不断更新，so ，尾节点是 -1 ！！ 
    cout << endl;
    
    return 0;
}


2.双向链表
//实现一个双链表，双链表初始为空，支持 5 种操作：
//在最左侧插入一个数；
//在最右侧插入一个数；
//将第 k 个插入的数删除；
//在第 k 个插入的数左侧插入一个数；
//在第 k 个插入的数右侧插入一个数
//现在要对该链表进行 M 次操作，进行完所有操作后，从左到右输出整个链表。
//注意:题目中第 k 个插入的数并不是指当前链表的第 k 个数。例如操作过程中一共插入了 n 个数，则按照插入的时间顺序，这 n 个数依次为：第 1 个插入的数，第 2 个插入的数，…第 n 个插入的数。

//输入格式
//第一行包含整数 M，表示操作次数。
//接下来 M 行，每行包含一个操作命令，操作命令可能为以下几种：
//L x，表示在链表的最左端插入数 x。
//R x，表示在链表的最右端插入数 x。
//D k，表示将第 k 个插入的数删除。
//IL k x，表示在第 k 个插入的数左侧插入一个数
//IR k x，表示在第 k 个插入的数右侧插入一个数 

//输出格式
//共一行，将整个链表从左到右输出。

//数据范围
//1≤M≤100000
//所有操作保证合法。

//输入样例：
//10
//R 7
//D 1
//L 3
//IL 2 10
//D 3
//IL 2 7
//L 8
//R 9
//IL 4 7
//IR 2 2

//输出样例：
//8 7 7 3 2 9

//第一遍  2022/03/13
//第二遍  2022/03/28
//第三遍  2022/04/11 
#include <iostream>
using namespace std;
const int N = 1e5+10;
int e[N],l[N],r[N],idx;

void init()					//链表要   初始化！初始化！初始化！ 
{
    r[0] = 1,l[1] = 0;		// 0 表示左端点，1 表示右端点
    idx = 2;				// 从 2 开始存储下标 （ 0 1代表做右端点） 
}

//在下标为 k 的点的右边插入 x
void addr(int k,int x)
{
    e[idx] = x;             //让当前结点的值为 x
    r[idx] = r[k];          //让当前结点的右边指向 k 的下一个结点
    l[idx] = k;             //让当前结点的左边指向 k 结点
    l[r[k]] = idx;          //让 k+1 结点左边指向当前结点
    r[k] = idx;             //让 k  结点右边指向当前结点
    idx++;
}

//删除第k个结点( 让 k 的左右节点跳过 k 即可） 
void remove(int k)			//删除一个节点，注意下标！！！ 
{
    l[r[k]] = l[k];         //让 k 右边的结点指向 k 左边的结点
    r[l[k]] = r[k];         //让 k 左边的结点指向 k 右边的结点
}

int main()
{
    int m;
    cin >> m;
    
    init();					//链表要   初始化！初始化！初始化！ 
    
    int k,x;
    string op;
    while(m--)
    {
        cin >> op;
        if(op == "L")
        {
            cin >> x;
            addr(0,x);
        }
        else if(op == "R")
        {
            cin >> x;
            addr(l[1],x);
        }
        else if(op == "D")
        {
            cin >>k;
            remove(k+1);									//由于 0 下标被左端点占用，因此，第 k 个数字的下标是 k+1 
        }
        else if(op == "IL")
        {
            cin >> k >> x;
            addr(l[k+1],x);									//由于 0 下标被左端点占用，因此，第 k 个数字的下标是 k+1 
        }
        else
        {
            cin >> k >> x;
            addr(k+1,x);									//由于 0 下标被左端点占用，因此，第 k 个数字的下标是 k+1 
        }
    }
    
    for(int i=r[0];i!=1;i=r[i]) cout << e[i] << ' ';		//特殊遍历方式，利用数组模拟链表的特性 ， 尾节点就是右端点 1 ！！ 
    cout << endl;											//不能用 puts 不信你瞧！ 
    
    return 0;
} 
