//给定你一个长度为 n 的整数数列。
//请你使用快速排序对这个数列按照从小到大进行排序。
//并将排好序的数列按顺序输出。

//输入格式
//输入共两行，第一行包含整数 n。
//第二行包含 n 个整数（所有整数均在 1～109 范围内），表示整个数列。

//输出格式
//输出共一行，包含 n 个整数，表示排好序的数列。

//数据范围
//1≤n≤100000

//输入样例：
//5
//3 1 2 4 5

//输出样例：
//1 2 3 4 5

//第一遍  2022/03/16
//第二遍  2022/04/12
//第三遍  2022/04/17 
#include <iostream>
using namespace std;
const int N = 1e6 + 10;
int q[N];
void quick_sort(int q[],int l,int r)						//使用前后两个指针快速排序 
{
    if(l>=r) return;										//如果区间不存在，不用排序 
    														//设定 i j两个指针（从边界外侧开始）, 采用 “分治 ”的思想，随机取值确定左边界为 x
    int x = q[l+r>>1] , i = l-1 , j = r + 1;				//也可取其他地方，但要注意边界问题防止死循环（递归时，左右区间相等 ） 
    
    while(i < j)											//如果 i j 还未相遇 
    {
        do i++ ; while (q[i]<x);							// i 先前进一步，如果 q[i] 的值小于选定的边界 x ，则继续前进 
        do j-- ; while (q[j]>x);							// j 先后退一步，如果 q[j] 的值大于选定的边界 x ，则继续后退 
        if(i<j) swap(q[i],q[j]);
    }
    quick_sort(q,l,j);										//递归左边已经排好序的区间 （边界问题与x的选定有关） 
    quick_sort(q,j+1,r);									//递归右边已经排好序的区间 （边界问题与x的选定有关） 
}

int main()
{
    int n;
    scanf("%d",&n);
    
    int i;
    for(i=0;i<n;i++) scanf("%d",&q[i]);
    
    quick_sort(q,0,n-1);
    
    for(i=0;i<n;i++) printf("%d ",q[i]);
    
    return 0;
}
