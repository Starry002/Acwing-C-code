//输入一个 n 行 m 列的整数矩阵，再输入 q 个操作，每个操作包含五个整数 x1,y1,x2,y2,c，其中 (x1,y1) 和 (x2,y2) 表示一个子矩阵的左上角坐标和右下角坐标。
//每个操作都要将选中的子矩阵中的每个元素的值加上 c。
//请你将进行完所有操作后的矩阵输出。

//输入格式
//第一行包含整数 n,m,q。
//接下来 n 行，每行包含 m 个整数，表示整数矩阵。
//接下来 q 行，每行包含 5 个整数 x1,y1,x2,y2,c，表示一个操作。

//输出格式
//共 n 行，每行 m 个整数，表示所有操作进行完毕后的最终矩阵。

//数据范围
//1≤n,m≤1000,
//1≤q≤100000,
//1≤x1≤x2≤n,
//1≤y1≤y2≤m,
//-1000≤c≤1000,
//-1000≤矩阵内元素的值≤1000

//输入样例：
//3 4 3
//1 2 2 1
//3 2 2 1
//1 1 1 1
//1 1 2 2 1
//1 3 2 3 2
//3 1 3 4 1

//输出样例：
//2 3 4 1
//4 3 4 1
//2 2 2 2

//第一遍  2022/04/04
//第二遍  2022/04/25 
#include <iostream>
using namespace std;
const int N = 1e3+10;
int n,m,q;
int a[N][N],b[N][N];                                        // a 是原矩阵 ， b 是差分矩阵 

void insert(int x1,int y1,int x2,int y2,int c)				//插入函数 （容斥原理，可以画图理解，数组下标代表的不是点，而是一个小方格！！） 
{
    b[x1][y1] += c;											//给 (x1,y1) 后的所有格子加上 c 
    b[x2+1][y1] -= c;										//减去右边多出来的
    b[x1][y2+1] -= c;										//减去下面多出来的 
    b[x2+1][y2+1] += c;										//加上多减去的 
}

int main ()
{
    scanf("%d%d%d",&n,&m,&q);
    for(int i=1;i<=n;i++)									//差分矩阵初始化（下标从 1 开始！！）  
    {
        for(int j=1;j<=m;j++)
        {
            scanf("%d",&a[i][j]); 
            insert(i,j,i,j,a[i][j]);						//给 b 中插入 a 的初始值，给 (i,j) 加上 a[i][j] 同时给后面的格子减上 a[i][j]，构造差分矩阵（让 b 是 a 的子项） 
        }
    }
    
    while(q--)
    {
        int x1,y1,x2,y2,c;
        scanf("%d%d%d%d%d",&x1,&y1,&x2,&y2,&c);
        insert(x1,y1,x2,y2,c);								//给 (x1,y1) ~~ (x2,y2) 区域加上 c 
    }
    
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            b[i][j] += b[i-1][j] + b[i][j-1] - b[i-1][j-1];	//求子矩阵和 （注意区别与子矩阵和公式的差别！） 
            printf("%d ",b[i][j]);
        }
        puts("");
    }
    
    return 0;
}
