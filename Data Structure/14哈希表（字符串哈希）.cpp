//给定一个长度为 n 的字符串，再给定 m 个询问，每个询问包含四个整数 l1,r1,l2,r2，请你判断 [l1,r1] 和 [l2,r2] 这两个区间所包含的字符串子串是否完全相同。
//字符串中只包含大小写英文字母和数字。

//输入格式
//第一行包含整数 n 和 m，表示字符串长度和询问次数。
//第二行包含一个长度为 n 的字符串，字符串中只包含大小写英文字母和数字。
//接下来 m 行，每行包含四个整数 l1,r1,l2,r2，表示一次询问所涉及的两个区间。
//注意，字符串的位置从 1 开始编号。

//输出格式
//对于每个询问输出一个结果，如果两个字符串子串完全相同则输出 Yes，否则输出 No。
//每个结果占一行。

//数据范围
//1≤n,m≤105

//输入样例：
//8 3
//aabbaabb
//1 3 5 7
//1 3 6 8
//1 2 1 2

//输出样例：
//Yes
//No
//Yes

//第一遍  2022/03/27 
//第二遍  2022/04/10 
#include <iostream>
using namespace std;
typedef unsigned long long ULL;						//定义无符号类型长整数，溢出就相当于对 Q 取模 
const int N = 1e5+10 , P = 131;						// P = 131 或 13331 ， Q=2^64，在99%的情况下不会出现冲突（yxc经验之谈） ，冲突就是 RP 不行 
int n,m;
char str[N];										//字符数组存储字符串，方便预处理！！！ 
ULL h[N],p[N];										// h[i] 对应的是前 i 个字符的哈希值 ， p[i] 对应的是 P 的 i 次方

int get(int l,int r)								//将字符串变成一个 P 进制的数字，体现了字符+顺序 ，需要确保不同的字符串对应不同的数字 
{
    return h[r] - h[l-1] * p[r-l+1];				//求子串的哈希值 
}													//PS ：核心是先把两个前缀和 对齐位数 ，然后做差 （因为子串的位数低 ， 哈希值前面又是高位，所以要先对齐位数） 
													//例如： 12345 的所有前缀和为（1 12 123 1234 12345），求子串 45 相当于 12345 - 123*100
int main()											
{													
    scanf("%d%d%s",&n,&m,str+1);
    
    p[0] = 1;										// P 的零次方等于 1 
    for(int i=1;i<=n;i++)							//从 1 开始存储字符（任意字符不可以映射成 0，否则 p[i] = p[i-1] * P 会出现不同的字符串都映射成 0 的情况，比如A,AA,AAA皆为 0 ） 
    {
        p[i] = p[i-1] * P;							//预处理每一位 P 进制的值 
        h[i] = h[i-1] * P + str[i];					//前缀和公式：预处理字符串的哈希值 
    }

    while(m--)
    {
        int l1,l2,r1,r2;
        scanf("%d%d%d%d",&l1,&r1,&l2,&r2);
        if(get(l1,r1) == get(l2,r2))puts("Yes");
        else puts("No");
    }
    
    return 0;
}
