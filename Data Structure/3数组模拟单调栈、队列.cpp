1.单调栈
//给定一个长度为 N 的整数数列，输出每个数 左边第一个 比它小的数，如果不存在则输出 -1。

//输入格式
//第一行包含整数 N，表示数列长度。
//第二行包含 N 个整数，表示整数数列。
//
//输出格式
//共一行，包含 N 个整数，其中第 i 个数表示第 i 个数的左边第一个比它小的数，如果不存在则输出 -1。

//数据范围
//1≤N≤105
//1≤数列中元素≤109

//输入样例：
//5
//3 4 2 7 5

//输出样例：
//-1 3 -1 2 2

//第一遍  2022/3/14
//第二遍  2022/3/30 
#include <iostream>
using namespace std;
const int N = 1e5+10;
int stk[N],tt;
int main ()
{
    int n;
    cin >> n;
    
    while(n--)
    {
        int x;
        cin >> x;
        
        while (tt && stk[tt] >= x) tt--;		//如果tt存在并且 大于 x就删掉，保证单调性 (单调递增） 
        if(tt) cout << stk[tt] << ' ';			//从 1 开始存储下标 ，方便判断队列是否为空（下标为 0 ）
        else cout << -1 << ' ';
        
        stk[ ++tt ] = x; 						//从 1 开始存储下标 ，方便判断队列是否为空（下标为 0 ） 
    }
    
    return 0;
}


2.单调队列
//给定一个大小为 n≤106 的数组。
//有一个大小为 k 的滑动窗口，它从数组的最左边移动到最右边。
//你只能在窗口中看到 k 个数字。
//每次滑动窗口向右移动一个位置。
//以下是一个例子：
//该数组为 [1 3 -1 -3 5 3 6 7]，k 为 3。
//     窗口位置	      最小值	最大值
//[1 3 -1] -3 5 3 6 7	-1		  3
//1 [3 -1 -3] 5 3 6 7	-3	  	  3
//1 3 [-1 -3 5] 3 6 7	-3		  5
//1 3 -1 [-3 5 3] 6 7	-3		  5
//1 3 -1 -3 [5 3 6] 7 	 3		  6
//1 3 -1 -3 5 [3 6 7]	 3		  7
//你的任务是确定滑动窗口位于每个位置时，窗口中的最大值和最小值。

//输入格式
//输入包含两行。
//第一行包含两个整数 n 和 k，分别代表数组长度和滑动窗口的长度。
//第二行有 n 个整数，代表数组的具体数值。
//同行数据之间用空格隔开。

//输出格式
//输出包含两个。
//第一行输出，从左至右，每个位置滑动窗口中的最小值。
//第二行输出，从左至右，每个位置滑动窗口中的最大值。

//输入样例：
//8 3
//1 3 -1 -3 5 3 6 7

//输出样例：
//-1 -3 -3 -3 3 3
//3 3 5 5 6 7

//第一遍  2022/3/14
//第二遍  2022/3/30
#include <iostream>
using namespace std;
const int N = 1e6+10;
int n,k,i;
int a[N],q[N];											//a[N]是存放数字的数组，q[N]是存放队列 下标 的数组 

int main()
{
    scanf("%d%d",&n,&k);
    for(i=0;i<n;i++) scanf("%d",&a[i]);

    int hh = 0,tt=-1;
    for(i=0;i<n;i++)									//输出每个位置滑动窗口中的最小值 
    {
        if(hh<=tt && i-k+1>q[hh]) hh++;					//弹出队头（划出窗口） 
        while (hh<=tt && a[q[tt]] >= a[i]) tt--;		//如果队尾大于当前位置，就扔掉（因为当前位置只要存在一天，队尾就永无翻身之日） 
        q[++tt] = i;
        if(i >= k - 1)printf("%d ",a[q[hh]]);			//如果队列中还存在元素，输出队头，即最小值 
    }
    cout << endl;
    
    hh = 0,tt=-1;
    for(i=0;i<n;i++)									//输出每个位置滑动窗口中的最大值  
    {
        if(hh<=tt && i-k+1>q[hh]) hh++;					//弹出队头（划出窗口） 
        while (hh<=tt && a[q[tt]] <= a[i]) tt--;		//如果队尾小于当前位置，就扔掉（因为当前位置只要存在一天，队尾就永无翻身之日） 
        q[++tt] = i;
        if(i >= k - 1)printf("%d ",a[q[hh]]);			//如果队列中还存在元素，输出队头，即最大值 
    }
    cout << endl;
    
    return 0;
}
