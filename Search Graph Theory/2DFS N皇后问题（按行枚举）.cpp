// n 皇后问题是指将 n 个皇后放在 n×n 的国际象棋棋盘上，使得皇后不能相互攻击到，即任意两个皇后都不能处于同一行、同一列或同一斜线上。
//现在给定整数 n，请你输出所有的满足条件的棋子摆法。

//输入格式
//共一行，包含整数 n。

//输出格式
//每个解决方案占 n 行，每行输出一个长度为 n 的字符串，用来表示完整的棋盘状态。
//其中 . 表示某一个位置的方格状态为空，Q 表示某一个位置的方格上摆着皇后。
//每个方案输出完成后，输出一个空行。
//注意：行末不能有多余空格。
//输出方案的顺序任意，只要不重复且没有遗漏即可。

//数据范围
//1≤n≤9

//输入样例：
//4

//输出样例：
//.Q..
//...Q
//Q...
//..Q.
//
//..Q.
//Q...
//...Q
//.Q..

//第一遍  2022/3/28 
#include <iostream>
using namespace std;
const int N = 20;
char g[N][N];											//保存路径（棋盘） 
bool col[N],dg[N],udg[N];								//记录当前位置是否可以放皇后（每一列、对角线、反对角线） （保存状态） 
int n;
void dfs(int u)											//深度优先搜索 （按行遍历） ，不同搜索顺序 时间复杂度不同  所以搜索顺序很重要！ 
{
	int i;
    if(u == n)											//如果撞到南墙了 
    {
        for(i=0;i<n;i++) puts(g[i]);					//输出当前路径中的所有皇后 
        puts("");
        return;
    }
    
    for(i=0;i<n;i++)									//每一列空位上可以选择的数字为:1 ~ n  （按列遍历） 
    {   
        if(!col[i] && !dg[i+u] && !udg[i-u+n])			//如果第 i 位数字没有被用过 （ i+u 和 i-u 是对角线的截距 ， 为确保下标是整数，给 i-u 加偏移量 n） 
        {
            g[u][i] = 'Q';								//将第 i 个皇后保存到棋盘当中 
            col[i] = dg[i+u] = udg[i-u+n] = true;		//标记第 i 位不可以放皇后 
            dfs(u+1);									//递归填下一行， 不撞南墙不回头 
            col[i] = dg[i+u] = udg[i-u+n] = false;		//回溯，删除第 i 位的标记（恢复现场） 
            g[u][i] = '.';
        }

    }
}

int main()
{
    cin >> n;
    for(int i=0;i<n;i++)
    	for(int j=0;j<n;j++)
    		g[i][j] = '.';
    dfs(0);
    return 0;
}

