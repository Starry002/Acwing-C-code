// n 皇后问题是指将 n 个皇后放在 n×n 的国际象棋棋盘上，使得皇后不能相互攻击到，即任意两个皇后都不能处于同一行、同一列或同一斜线上。
//现在给定整数 n，请你输出所有的满足条件的棋子摆法。

//输入格式
//共一行，包含整数 n。

//输出格式
//每个解决方案占 n 行，每行输出一个长度为 n 的字符串，用来表示完整的棋盘状态。
//其中 . 表示某一个位置的方格状态为空，Q 表示某一个位置的方格上摆着皇后。
//每个方案输出完成后，输出一个空行。
//注意：行末不能有多余空格。
//输出方案的顺序任意，只要不重复且没有遗漏即可。

//数据范围
//1≤n≤9

//输入样例：
//4

//输出样例：
//.Q..
//...Q
//Q...
//..Q.
//
//..Q.
//Q...
//...Q
//.Q..

//第一遍  2022/3/28 
#include <iostream>
using namespace std;
const int N = 20;
char g[N][N];													//保存路径（棋盘） 
bool row[N],col[N],dg[N],udg[N];								//记录当前位置是否可以放皇后（每一列、对角线、反对角线） （保存状态） 
int n;
void dfs(int x,int y,int s)							 			//深度优先搜索 （按元素遍历） ， 不同搜索顺序 时间复杂度不同  所以搜索顺序很重要！
{
	if(y==n) y = 0 , x++;										//遍历完一行就换行 
	
	if(x==n)													//遍历完所有元素 
	{
		if(s==n)												//皇后放完了的话，就输出 
		{
			for(int i=0;i<n;i++) puts(g[i]);
			puts("");
		}
		return;
	}
	
	dfs(x,y+1,s);												//不放皇后 
	
	if(!row[x] && !col[y] && !dg[x+y] && !udg[x-y+n])			//如果当前位置可以放皇后 
	{
		g[x][y] = 'Q';
		row[x] = col[y] = dg[x+y] = udg[x-y+n] = true;
		dfs(x,y+1,s+1);
		row[x] = col[y] = dg[x+y] = udg[x-y+n] = false;
		g[x][y] = '.';
	}		

}

int main()
{
    cin >> n;
    for(int i=0;i<n;i++)
    	for(int j=0;j<n;j++)
    		g[i][j] = '.';
    dfs(0,0,0);
    return 0;
}
